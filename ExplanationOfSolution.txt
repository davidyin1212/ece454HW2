In the final solution I used a combination of loop reordering and loop tiling as I realized those are the two best solution to optimizing cache performance. Loop tiling was used first with a random square tile size by trial and error it was determined that the best tile size was a 16x16 tile. This improved the performance quite drastically. Since by reducing the amount we had to rotate over it allowed more of the instruction to be held inside the cache thus reducing cache misses. However it was determined that if we had a better idea of exactly how large the cache was it could be optimized even more. Thus we used a profiling tool to determine that the cache size was 32K and since we know the size of each line should be 64B we could determine that there would be approximately 500 lines. Then we determined that we'll need equal number of lines for reads and writes as well as some additional space to hold the overhead required to implement the loop instruction so we decided that a good number to fit all this into the cache was a 8X128 tile. 8 since we can fit approximately 8 elements per line and 128 for each of the reads and writes. Finally we did some loop reordering. Reordering is faster since this allows to increase locality for the dst array which is better since this is a write operation which would will incur a larger penalty during a miss then a read by doing it this way you are loading an entire block of the dst array and changing it all and write it out as a block rather then doing it one at a time the trade off is that you now have to do the read one at a time but that's okay since write has a larger miss penalty then read since you have to write the information back out again. The working solution employees both these two techniques to get an overall result of 2.9.